# AI時代のソフトウェアエンジニアリング
Xの記事機能を使ってみたいので、以前から考えていたAI時代のソフトウェアエンジニアリングについて書いてみる。

## はじめに

AIでコードを書く速度は上がった。しかし、開発がすぐ終わるわけではない。
コードを書く速度に対して、正しさを検証する速度が追いつかないからだ。

本稿では、この問題への対処を整理する。
結論は「検証可能性を上げ、検証もAIで回せる形にする」ことだ。

## 1. なぜ開発はすぐ終わらないのか

開発はコードを書くことだけではない。書いたコードが正しいかを検証することも含まれる。

AIで速くなるのはコードを書く部分だ。まだ検証はコードほどは早くなっていない。レビュー、動作確認は依然として人手がかかる部分もある。コードが増えれば、検証の負荷も増える。だから、コードを書く速度が上がっても、開発全体はすぐ終わらない。検証がボトルネックになる。

しかし、検証を省略するわけにもいかない。

Software Engineering at Googleは、ソフトウェアエンジニアリングを「時間の経過に耐えるプログラミング」と捉えている。変更が積み重なっても、品質と運用が保たれることが要点だ。そのためには、変更の正しさを短い周期で確認できなければならない。テストやCI/CDといったソフトウェアエンジニアリングのベストプラクティスは、このために存在する。

つまり、検証を省略すれば、品質と運用が崩れる。
なので、検証可能性を高め、検証もAIで回せる形にしなければならない。
これがAI時代のソフトウェアエンジニアリングだ。

## 2. 検証可能性とは何か

検証可能性が高い状態とは、次の2つが揃っていることだ。

1. 正しさの基準が明文化されている
2. AIがテスト・レビュー・実行時検証を機械的に回せる

正しさの基準と検証手段は、3つの層で整理できる。

- 仕様: 何を作るか、どこまでやるか
- 設計: どう作るか、なぜそうするか
- 検証基盤: テスト、CI、レビュー、実行時検証をAIが回せる状態

## 3. 検証可能性を上げる資産

検証可能性を上げるには、2種類の資産が必要だ。

判断基準を作る資産

- 仕様: 要求、境界条件、受け入れ基準
- 設計: モジュール構成、データモデル、API境界
- ADR: 判断の理由と選ばなかった選択肢
- コメント: 意図と前提
- ルールと規約: 迷いを減らす決め事

検証をAIで回すための環境資産

- テストとCI: 正しさの定義と自動検証
- レビュー基準: 人/AIレビューの観点と合否条件
- 実行時検証: ログ・メトリクス・カナリアで正しさを確かめる条件
- ビルドと実行の接続: AIがビルドを実行し、起動したアプリケーションにAIがアクセスできること
- 開発環境へのアクセス: AIが自分の実行環境を直接見られること
- ログの可視性: AIがログを読めること

## 4. 具体例

正しさの基準と検証手順が、AIに渡せる形で実装されている必要がある。以下に具体例を示す。

### Docs構成の例

```
docs/
  README.md      # どこに何があるか、読む順番
  architecture/  # 全体構成、依存関係、データ境界
  how-to/        # 作業手順、手順の分岐、実行例
  plans/         # 計画、マイルストーン、前提
  adr/           # 判断理由と代替案
```

この構成で、AIは「どの文書を読めばよいか」と「判断の根拠」を同じ場所から取得できる。

### AGENTS.mdの例

AGENTS.mdは、AIがコードベースを理解し、検証を回すためのガイドだ。

```markdown
# プロジェクト概要
このリポジトリはXXXを行うAPIサーバーです。

# ドキュメント
- docs/README.md: ドキュメントの目次
- docs/architecture/: 設計判断の背景
- docs/adr/: 意思決定の記録

# 開発ワークフロー
1. `npm test` でテストを実行
2. `npm run lint` で静的解析
3. `npm run typecheck` で型チェック

# 検証の成功条件
- 上記3つのコマンドがすべてエラーなしで完了すること
```

ポイントは、成功条件が機械的に判定できることだ。

これらの具体例に共通するのは、「正しさの基準」と「検証の回し方」を機械に渡せる形にしていることだ。
この他にもskillsとか色々なやり方はあるが、重要なのはこの二つを実現することだ。
## まとめ

- AIを活かす鍵は、検証可能性を上げ、検証をAIで回せる形にすること
- そのための資産は2種類ある
  - 判断基準を作る資産: 仕様、設計、ADR、コメント、ルールと規約
  - 検証を回す環境資産: テスト、CI、レビュー基準、実行時検証、ログの可視性
- AI時代のソフトウェアエンジニアリングとは、検証可能性を上げることだ

とはいえ、これを全部やったとしてもUI、UX等はやっぱり人が見ないといけないので、完全にAIでやるのは難しい。
CLIとかだと楽なので、CLIツールはめちゃくちゃ発展しそうだ。

## 参考文献

- Software Engineering at Google, Chapter 1
