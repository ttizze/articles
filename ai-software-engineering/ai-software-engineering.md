# AI時代のソフトウェアエンジニアリング

## はじめに

AIでコードを書く量は爆増しました。しかし、ソフトウェア開発全体のスピードは爆増していません。なぜでしょうか？

この記事では、AIを活用した開発でボトルネックがどこに移動したのか、そしてそれをどう解決するのかを考えます。結論から言えば、**AI時代のソフトウェアエンジニアリング＝検証可能性と不確実性耐性を上げること**です。

## 1. AIでボトルネックが移動した

### 量は増えた

GitHub Octoverse 2025によると、数値は明確に増加しています：

- PRマージ **43.2M/月（+23% YoY）**
- Code push **82.19M/月**
- コミット **986M/年（+25% YoY）**

### しかし全体として速くなってはいない

ここでいう「速さ」は、**リードタイムやデリバリ頻度**のような開発全体の速度を指します。

Atlassian State of DevEx 2025のデータは興味深い事実を示しています：

- **68%がAIで週10時間以上"節約"**
- **50%が非コーディングの非効率で週10時間以上"喪失"**

AIで得た速さが、組織の摩擦で相殺されている可能性があります。

### レビュー負荷が熟練者に集中

arXiv 2510.10165の研究では：

- **コア開発者のレビュー負担 +6.5%**
- **コア開発者の"自分のコード生産性" -19%**

PRの増加や質のばらつきが、レビュー負荷を押し上げている可能性があります。

### AIレビューでも遅くなるケース

arXiv 2412.18531によると、AIレビューを導入した環境では：

- PRクローズ時間が **5h52m → 8h20m** に増加
- ボットのコメント対応が増える
- スコープ外・無関係な指摘が混ざる

AIレビューは有用でも、全体のリードタイムは悪化することがあります。

### ボトルネックの移動

コーディングは相対的に解決されつつあります。しかし、ソフトウェアエンジニアリング全体のボトルネックはまだ解決していません。ボトルネックは「コーディング」から「仕様・検証・レビュー・運用」へ移動したのです。

## 2. なぜ遅いのか？判断基準が曖昧だから

新たなボトルネックである「仕様・検証・レビュー・運用」に共通するのは、**「答えが曖昧」** なことです。答えが曖昧だとAIは迷子になります。人間でも迷います。だから必要なのは、**答えを一発で断定すること**ではなく、**不確実性を下げ、判断を再現可能にする仕組み**です。

### バイブコーディング＝曖昧なまま進める典型

バイブコーディングでMVPは作れます。しかし保守できません：

- 実装の意図がわからない
- 壊れたら直せない

なぜか？正しい答えがわからないからです。

### 不確実性を下げる仕組みが必要

これはソフトウェアエンジニアリングがやってきたことです。

## 3. ソフトウェアエンジニアリングとは何か

Software Engineering at Googleの第1章に、印象的な一文があります：

> "Software engineering is programming integrated over time."

ソフトウェアエンジニアリングは3つの軸で考えます：

- **Time**：時間の経過と「変化の必要性」への備え
- **Scale**：規模と効率（ソフトウェアと組織の両方）
- **Trade-offs**：不正確な見積りを前提にした、高いステークの意思決定

### Timeの実例：長寿命プロジェクト

Google Search、Linux kernel、Apache HTTP Serverなど、終わりが読めない長期運用が前提のプロジェクトがあります。依存関係・OS・言語バージョンの変化に耐える必要があります。

### Scaleの実例：多人数・多版

人数が増えると、同じ作業が指数的に重くなります。レビュー待ち、マージ競合、CI滞留、リリース調整などです。

### Trade-offsの実例：変更の価値 vs 影響

変更には**効率・安全性・将来性**の価値があります。ただし**互換性の破壊**というコストが発生します。価値と痛みを評価して意思決定することが求められます。

## 4. ベストプラクティスは「答えの形」と「不確実性への耐性」を作る

ソフトウェアエンジニアリングのベストプラクティスは、単に「答えを出すため」だけにあるのではありません。**答えの質・責任・リスクを管理し、不確実性に耐える形を作る**ためにもあります：

- **コメント**：意図を伝える
- **ADR**：決定の根拠を残す
- **CI**：成功条件を自動検証
- **テスト**：期待する振る舞いを定義
- **リファクタリング**：構造を読みやすく保つ
- **観測性・運用手順**：答えが不確かでも壊れにくくする

### 答えがあるならAIに任せられる

検証できるなら自動化できます。自動化できるならAIに任せられます。ただし、**検証可能性だけでは足りません**。答えが揺れる領域に耐えるためには、**不確実性への耐性**も必要です。

## 5. 実践フロー

全体の流れは **壁打ち → 仕様 → 設計 → 実装 → 検証 → レビュー** です。

### 壁打ちで仕様を確定

「何を作るのか」を先に固めます。AIに仕様を言語化させましょう。仕様は検証可能性の出発点です。

### 仕様が固まったら実装

仕様 → 設計 → 実装の順序を崩してはいけません。コードより仕様が上位です。[^1]

### 検証可能性を作る

検証できるなら自動化できます。「仕様の形」を作ることが最重要です。同時に、**答えが不確かでも壊れにくい仕組み**（観測性・運用手順・段階的リリースなど）も必要です。

### AIに効くコード

AIが正しく振る舞う前提条件は：

- 型がある
- テストがある
- ルールがある

### でもテストは万能じゃない

全パターンの網羅は不可能です。テスト設計はコストが高いです。結局、**コードを読む**必要があります。

### コードを読む力

人間がコードを読む力は依然として重要です：

- 仕様と実装のズレを発見
- AIの「それっぽさ」を見破る
- 変更の影響範囲を把握

## まとめ

- **AIを活かすカギ＝検証可能性と不確実性耐性を上げること**
- それはソフトウェアエンジニアリングが大切にしてきたことでもある
- 最後は人間がコードを読む

AI時代だからこそ、ソフトウェアエンジニアリングの基本が重要になっています。

## 参考文献

- GitHub Octoverse 2025
- Atlassian State of DevEx 2025
- arXiv 2510.10165
- arXiv 2412.18531
- Software Engineering at Google, Chapter 1

[^1]: 探索的開発やプロトタイピングでは例外的に順序が前後することがあります。その場合も、最終的な仕様を明文化し直してから本実装に進めることが前提です。
